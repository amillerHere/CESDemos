{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Clamp function that check that a number `x` in between the bounds `[min, max]`\n *\n * @param {number} x Number to check\n * @param {number} min Minimum bound\n * @param {number} max Maximum bound\n * @return {number} `min` if `x <= min`, `x` if `min < x < max`, `max` if `x >= max`\n */\nexport function clamp(x: number, min: number, max: number) {\n  if (Number.isNaN(x)) return NaN;\n  return Math.min(Math.max(x, min), max);\n}\n\n/**\n * Simple debounce function, so it called once every given time.\n * Useful to use with events like resize, mousemove, etc.\n *\n * @param {(...args: T) => (PromiseLike<U> | U)} callback function to be debounced\n * @param {number} wait number in milliseconds\n * @returns {(...args: T) => Promise<U>}\n */\nexport function debounce<T extends unknown[], U>(\n  callback: (...args: T) => PromiseLike<U> | U,\n  wait: number\n) {\n  let timer: ReturnType<typeof setTimeout>;\n\n  return (...args: T): Promise<U> => {\n    clearTimeout(timer);\n    return new Promise(resolve => {\n      timer = setTimeout(() => resolve(callback(...args)), wait);\n    });\n  };\n}\n\n/**\n * Find the closest element with a given selector up to dom from the base element\n *\n * @param {string} selector selector for element to be found\n * @param {Element} base the element from which the search starts\n * @returns {T | null} first element found by selector or null\n */\nexport function closestElement<T extends Element>(selector: string, base: Element): T | null {\n  function findClosest(el: Element | Window | Document): Element | null {\n    if (!el || el === document || el === window) {\n      return null;\n    }\n    const found = (el as Element).closest(selector);\n    return found || findClosest(((el as Element).getRootNode() as ShadowRoot).host);\n  }\n\n  return findClosest(base) as T;\n}\n\n/**\n *\n * @param {string} name name of the CSS variable\n * @param {HTMLElement} el HTMLElement to get the CSS variable from, fallback to first `[data-theme]` element if `undefined`\n * @returns {string | undefined} the value of the CSS Variable\n */\nexport function getCSSVariable(name: string, el?: HTMLElement) {\n  const htmlElement = el || document.querySelector('[data-theme^=hds]');\n  return getComputedStyle(htmlElement)?.getPropertyValue(name).trim();\n}\n\n/**\n * Returns if a given slot or and array of nodes are empty\n *\n * @param {HTMLSlotElement | Array<Node>} slotEl\n * @returns {boolean}\n */\nexport function isSlotEmpty(slotEl: HTMLSlotElement | Array<Node>) {\n  let elements: Array<Node>;\n  if (slotEl instanceof HTMLSlotElement) {\n    elements = slotEl.assignedNodes({flatten: true});\n  } else {\n    elements = slotEl;\n  }\n  return elements.length === 0 || (elements.length === 1 && elements[0].textContent.trim() === '');\n}\n\n/**\n *\n * @param {string} tagName\n * @returns {(ctor: CustomElementConstructor) => void}\n */\nexport const customElement = (tagName: string) => (ctor: CustomElementConstructor) => {\n  const settings = window.hds || {};\n  const disableAutoCustomElementsDefine = !!settings.disableAutoCustomElementsDefine;\n\n  if (!disableAutoCustomElementsDefine) {\n    const tryGetBeforeCustomElementsDefine = !!settings.tryGetBeforeCustomElementsDefine;\n\n    if (\n      !tryGetBeforeCustomElementsDefine ||\n      (tryGetBeforeCustomElementsDefine && !window.customElements.get(tagName))\n    ) {\n      window.customElements.define(tagName, ctor);\n    }\n  }\n};\n\n/**\n * Format string template by passed arguments\n * @param template - original string template\n * @param args - arguments for replacement\n * @param keepNotMatched - if true will keep all unresolved params\n * @example stringFormat('hello {0}', {0: 'world'}) => 'hello world'\n * @example stringFormat('hello {name}', {name: 'Dmytro'}) => 'hello Dmytro'\n * @example stringFormat('hello {world} {name}', {name: 'Dmytro'}, true) => 'hello {world} Dmytro'\n * @returns - fromatted string\n */\nexport const stringFormat = (\n  template: string,\n  args: {[key: string | number]: any},\n  keepNotMatched: boolean = false\n) => {\n  if (template) {\n    const keys = Object.keys(args);\n    return template.replace(\n      /{([a-zA-Z0-9]+)}/g,\n      (_, match) => args[match] || args[keys[match]] || (keepNotMatched ? `{${match}}` : '')\n    );\n  }\n  return template;\n};\n"]}